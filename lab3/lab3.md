# 第三次实验报告

姓名: 宋家鑫

学号: 2425121022

班级: 24软件工程一班

---

## 实验目的

使学生深入了解栈的特性，以便在实际问题背景下灵活运用它；巩固对栈这种线性结构的构造方法与基本操作的实现；通过典型应用（进制转换、括号/表达式求值、迷宫求解）体会栈在工程问题中的优势。

---

## 实验任务

1. 进制转换：借助自实现的栈，将十进制整数转换为 N 进制（N=2, 8, 16）。
2. 括号匹配：输入只含小括号的表达式，检测括号是否匹配（本实验在“表达式求值”中一并实现并验证）。
3. 选做应用：
	 - 表达式求值：支持 `+ - * / %`、小数与一元负号、括号及优先级。
	 - 迷宫最短步数：用栈配合剪枝与记忆化搜索，求从左上到右下的最少步数。

对应代码：
- `lab3_0.cpp`：进制转换
- `lab3_1.cpp`：表达式求值（含括号匹配检测）
- `lab3_2.cpp`：迷宫问题（最少步数）
- `stack.hpp`：自实现顺序栈模板（供以上程序复用）

---

## 公共数据结构（stack.hpp）

**顺序栈模板 `stack<T>`：**
- **核心成员**：`elems_`（动态数组）、`size_`（容量）、`usedSize_`（元素数）。
- **基本操作**：`push`、`pop`、`top`、`empty`、`size`，必要时自动扩容（`size_ = size_*2+1`）。
- **异常处理**：空栈 `top/pop` 抛出错误字符串（简化处理）。

特点：不依赖标准库栈；接口简洁，满足题目“不得用库栈”的要求。

---

## Task 1: 进制转换（lab3_0.cpp）

### 思路与数据结构

- 用栈逆序输出余数序列：持续“除以基数 N，取余数”，每次余数入栈，最后依次出栈即为高位到低位。
- 映射表 `CHAR[16]`：`0-9` 与 `a-f`，支持十六进制输出。
- 统一处理正负与零：
	- `0` 直接输出 `0`；
	- 负数先转正数绝对值打印，前面加 `-` 号。

### 关键实现

1. 字符表初始化 `char_init()`：生成 `0-9` 与 `a-f`。
2. 绝对值处理 `decimal_handler()`：将 `long long` 转 `unsigned long long` 以处理极值。
3. 通用打印函数 `print(base, decimal)`：按 `base∈{2,8,16}` 进行入栈/出栈打印。
4. 封装接口：`hex_print`、`oct_print`、`bin_print`。

### 复杂度

- 时间：$O(k)$，$k$ 为转换后数字位数。
- 空间：$O(k)$，用于保存余数栈。

### 示例

输入：`26`

输出：
```
hex version: 1a
oct version: 32
bin version: 11010
```

输入：`-255`

输出：
```
hex version: -ff
oct version: -377
bin version: -11111111
```

---

## Task 2: 表达式求值 & 括号匹配（lab3_1.cpp）

本任务同时验证“括号匹配”：若括号不匹配，将无法正确归约并抛出异常/提前失败。

### 思路与数据结构

- 两个栈：
	- `operandStack`（数值栈，`double`）。
	- `operatorStack`（运算符栈，枚举 `TYPE`）。
- 一个队列：`queue<char>`（用两个栈实现），临时缓存连续的数字字符与小数点，形成一个数。
- 词法判定：`judgeType(c, preType)` 区分 `NUM/DOT/ADD/MIN/MUL/DIV/MOD/BRACKETL/BRACKETR/NEG`（`NEG` 为一元负号）。
- 优先级：`NEG(4) > MUL/DIV/MOD(3) > ADD/MIN(2) > BRACKETL(1)`。

### 关键实现

1. 读取：使用 `cin.get()` 逐字符读取至换行，忽略空白。
2. 成数：当遇到非数字/点时，若 `digitQueue` 非空，则调用 `getNum()` 生成一个 `double` 入 `operandStack`。
3. 归约：
	 - 左括号 `(` 入栈。
	 - 右括号 `)`：弹栈直至遇到 `(`，实现括号内完全归约（括号匹配的体现）。
	 - 一般运算符：根据优先级弹出更高或相等优先级的运算符并计算，再将当前运算符入栈；一元负号 `NEG` 采取右结合策略（仅弹出更高优先级）。
4. 计算：`calculate(operandStack, op)` 支持 `+,-,*,/,%,NEG`；`%` 对参与值取整后再求模。
5. 收尾：处理残余数字与运算符，最终输出两位小数。

### 正确性与健壮性说明

- 一元负号判定：若 `-` 前为右括号/数字/点，则视作二元减；否则视作一元负。
- 括号匹配：`BRACKETR` 必须在栈中匹配到 `BRACKETL`，否则无法完成归约（隐式检测）。
- 边界情形（工程可再增强）：
	- 除零未显式处理，输入应避免 `a/0` 或整模 `a%0`。
	- 取模将 `double` 转 `int`，存在小数截断语义，属题目范畴内合理简化。

### 复杂度

- 时间：$O(n)$，单次线性扫描并伴随常数次入栈/出栈。
- 空间：$O(n)$，数字/运算符临时栈与队列。

### 示例

输入：`1+2*3-4/2` → 输出：`5.00`

输入：`-(3+5)*2+10/4` → 输出：`-12.50`

输入：`(2+3)*(4-1.5)` → 输出：`12.50`

输入：`10%3+6/4` → 输出：`3.50`（`10%3==1`，`6/4==1.5`）

---

## Task 3: 迷宫最少步数（lab3_2.cpp）

问题：给定 `row×col` 矩阵，`0` 为可走、`1` 为墙，从 `(1,1)` 走到 `(row,col)` 的最少步数（四邻接）。

### 思路与数据结构

- 使用显式栈进行 DFS 搜索，配合：
	- `dp[i][j]` 记录到达 `(i,j)` 的最少步数（记忆化剪枝）。
	- 全局 `minSteps` 维护当前最优解，再剪枝 `steps>=minSteps`。
	- `judge(pos, steps)` 统一检查越界/撞墙/劣解。
- 方向数组 `dx,dy`：右、下、左、上。

### 关键实现

1. 输入：`row col`，随后读入矩阵；内部使用从 1 开始的下标。
2. 初始化：起点 `(1,1)` 若可走，则入栈并设置 `dp[1][1]=1`。
3. 扩展：弹栈取状态 `(x,y,steps)`，若到达终点则刷新 `minSteps`；否则按 4 个方向尝试扩展合法的下一步（更优步数才入栈）。
4. 结束：若 `minSteps==-1` 则无路可达，否则输出最少步数。

### 复杂度

- 最坏时间：$O(row\times col)$ 节点数级别，每个格子可被以更优步数刷新有限次。
- 空间：$O(row\times col)$，主要来自 `dp` 与显式搜索栈。

### 示例

输入：
```
input row and col:
3 3
input the matrix (0=path, 1=wall):
0 0 0
1 1 0
0 0 0
```
输出：`Minimum steps: 5`

---

## 复杂度小结

- 进制转换：时间 $O(k)$、空间 $O(k)$。
- 表达式求值：时间 $O(n)$、空间 $O(n)$。
- 迷宫最短步数：时间与空间 $O(row\times col)$ 量级。

---

## 总结

**核心收获**
- 自实现顺序栈的接口设计与扩容策略。
- 表达式求值中一元负号判定、优先级与括号驱动的归约过程。
- 用栈组织搜索状态，并结合记忆化/剪枝提升搜索效率。

**关键难点**
- 一元负号与二元减号的区分与右结合处理。
- 括号匹配的边界处理（空栈、嵌套），以及与优先级的相互作用。
- 迷宫搜索中避免重复与劣解：`dp` 记忆化与全局 `minSteps` 剪枝的配合。

**扩展思考**
- 迷宫问题若需求最短路径，BFS 更直接且天然最短；现实现为 DFS + 剪枝可作对照。
- 表达式可扩展幂运算、函数、变量与错误恢复；取模的浮点语义可进一步规范化。
- 可将括号匹配独立为函数，单独对输入串进行匹配性检测与错误定位。

