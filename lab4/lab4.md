# 第四次实验报告

姓名: 宋家鑫

学号: 2425121022

班级: 24软件工程一班

---

## 实验目的

使学生深入了解二叉树的基本特性和遍历操作；掌握二叉树遍历算法的递归与非递归实现；通过编程实践加深对栈、队列等辅助数据结构在树遍历中应用的理解；为后续学习树的其他操作和应用奠定基础。

---

## 实验任务

**二叉树的遍历（Binary Tree Traversal）**

基本要求：以二叉链表为存储结构，实现二叉树的先序、中序、后序三种次序的递归和非递归遍历。

扩展要求：有时间再实现二叉树的按层次遍历（利用队列）。

测试数据：以先序创建二叉树作为测试用例。

实现提示：设二叉树的结点不超过 30 个，且每个结点的数据均为字符，这样可利用类先序遍历序列作为输入顺序创建二叉树链表存储结构。

---

## 核心数据结构

### BST (Binary Search Tree) 二叉搜索树

**节点结构：**
```
template <typename T>
class BST {
  T value_;           // 节点值
  BST<T> *left_;      // 左子树指针
  BST<T> *right_;     // 右子树指针
}
```

**关键操作：**

#### 1. insert(T value) - 插入节点（非递归）
```
若 value > 当前节点，向右子树查找
若 value < 当前节点，向左子树查找
若 value == 当前节点，返回 false（不允许重复）
找到空位置后创建新节点
时间复杂度：O(h)，h 为树高
```

#### 2. 递归遍历
- `pre()` - 先序遍历（根-左-右）
- `inner()` - 中序遍历（左-根-右）
- `post()` - 后序遍历（左-右-根）

#### 3. 非递归遍历
- `preIter()` - 先序遍历（栈实现）
- `innerIter()` - 中序遍历（栈实现）
- `postIter()` - 后序遍历（栈实现）
- `layerIter()` - 层序遍历（队列实现）

**设计特点：**
- 采用二叉搜索树保证插入有序性
- 提供递归和非递归两种遍历方式对比
- 析构函数递归释放所有子节点内存

---

## 算法实现

### 1. 先序遍历（Pre-order）

**递归实现：**
```
访问根节点
递归遍历左子树
递归遍历右子树
```
时间复杂度：O(n)，空间复杂度：O(h)（递归栈）

**非递归实现（栈）：**
```
外循环：当前节点不为空或栈非空
  内循环：当前节点不为空
    访问当前节点
    当前节点入栈
    移动到左子树
  弹出栈顶节点
  移动到右子树
```
时间复杂度：O(n)，空间复杂度：O(h)（显式栈）

**关键点：** 先序遍历在"向左探索"时立即访问，栈用于记录待访问的右子树

---

### 2. 中序遍历（In-order）

**递归实现：**
```
递归遍历左子树
访问根节点
递归遍历右子树
```
时间复杂度：O(n)，空间复杂度：O(h)

**非递归实现（栈）：**
```
外循环：当前节点不为空或栈非空
  内循环：当前节点不为空
    当前节点入栈（不访问）
    移动到左子树
  弹出栈顶节点并访问
  移动到右子树
```
时间复杂度：O(n)，空间复杂度：O(h)

**关键点：** 中序遍历需要先探索到最左节点才访问，栈用于回溯到父节点

**特殊性质：** 对于二叉搜索树，中序遍历的结果是递增有序序列

---

### 3. 后序遍历（Post-order）

**递归实现：**
```
递归遍历左子树
递归遍历右子树
访问根节点
```
时间复杂度：O(n)，空间复杂度：O(h)

**非递归实现（栈 + last 指针）：**
```
维护 last 指针记录上一个访问的节点
外循环：当前节点不为空或栈非空
  内循环：当前节点不为空
    当前节点入栈（不访问）
    移动到左子树
  查看栈顶节点（不弹出）
  若右子树为空或右子树已访问（== last）
    弹出并访问该节点
    更新 last
    置当前节点为空（防止重复入栈）
  否则
    移动到右子树
```
时间复杂度：O(n)，空间复杂度：O(h)

**关键点：** 后序遍历最复杂，需要判断右子树是否已访问过，避免重复遍历

---

### 4. 层序遍历（Level-order）

**队列实现：**
```
根节点入队
循环：队列非空
  出队一个节点并访问
  若有左子树，左子树入队
  若有右子树，右子树入队
```
时间复杂度：O(n)，空间复杂度：O(w)，w 为树的最大宽度

**关键点：** 利用队列的先进先出特性实现同层节点按序访问

---

## 测试用例

**构建二叉搜索树：**
```
插入序列：50, 30, 70, 20, 40, 60, 80

生成的树结构：
          50
        /    \
      30      70
     /  \    /  \
   20   40  60  80
```

**结果展示：**


---

## 复杂度分析

**时间复杂度：** 所有遍历算法均为 O(n)，每个节点恰好访问一次

**空间复杂度：**
- 递归遍历：O(h)，递归栈深度等于树高
  - 平衡树：h = O(log n)
  - 退化为链表：h = O(n)
- 非递归遍历：O(h)，显式栈最大深度等于树高
- 层序遍历：O(w)，队列最大长度等于树的最大宽度
  - 完全二叉树：w ≈ n/2

---

## 总结

**核心收获：**
1. 深入理解递归与栈的等价性：递归本质上是系统维护调用栈
2. 掌握三种遍历的非递归实现技巧：
   - 先序：访问在入栈前
   - 中序：访问在出栈时
   - 后序：需要 last 指针判断右子树是否访问过
3. 层序遍历体现队列在广度优先搜索中的应用

**关键难点：**
- 后序非递归遍历的 last 指针维护
- 理解何时访问节点（入栈前、出栈时、判断后）
- 循环条件的设计（当前节点非空 OR 栈非空）
- 避免节点重复入栈（后序遍历中需要 `t = NULL`）
