# 第二次实验报告

姓名: 宋家鑫

学号: 2425121022

班级: 24软件工程一班

---

## 实验目的

帮助学生熟练掌握线性表的基本操作在链式存储结构上的实现，重点掌握循环链表的操作和应用。

---

## 实验任务

**约瑟夫环问题（Josephus Problem）**

编号为 1, 2, 3, ···, n 的 n 个人按顺时针方向围坐一圈，每人持有一个密码（正整数）。一开始选一个正整数作为报数上限值 m，从第一个人开始按顺时针方向自 1 开始顺序报数，报到 m 时停止报数。报 m 的人出列，将他的密码作为新的 m 的值，从他在顺时针方向上的下一个人开始重新从 1 报数，如此下去，直至所有的人全部出列为止。

---

## 核心数据结构

### LinkedList 循环链表实现

**关键成员：**
- `head_`：头指针
- `tail_`：尾指针
- `size_`：链表长度
- 循环特性：`tail_->next = head_`

**核心操作：**

#### 1. insert(T val) - 尾插法
```
空链表：head = tail = newNode, newNode->next = newNode
非空链表：newNode->next = head, tail->next = newNode, tail = newNode
时间复杂度：O(1)
```

#### 2. deleteNext(Node *node) - 删除后继节点
```
删除 node->next 节点
node->next = node->next->next
更新 size，若删空则重置 head 和 tail
时间复杂度：O(1)
```

**设计优势：**
- 尾插法 O(1) 建表
- 删除后继节点避免遍历找前驱
- 循环结构天然适配约瑟夫环

---

## 算法实现

### 约瑟夫环求解算法

**核心思路：** 维护前驱指针 `pre`，通过删除后继节点模拟出列

**算法步骤：**

1. **初始化**
   - 构建循环链表，每个节点存储 `Pair<编号, 密码>`
   - `pre` 指针指向 `tail`（相当于站在第 1 人前面）
   - 初始报数上限为 `m`

2. **循环出列**（直到链表为空）
   ```
   循环 m-1 次：pre = pre->next（相当于报数 m 次，停在第 m 人的前驱）
   输出 pre->next 的编号（第 m 人出列）
   更新 m = pre->next 的密码
   删除 pre->next
   ```

3. **关键点**
   - 为什么循环 `m-1` 次？因为删除的是 `pre->next`，需要让 `pre` 停在目标前驱位置
   - 删除后 `pre` 自动指向下一个人的前驱（因为 `pre->next` 已更新）
   - 链表为空时自动退出循环

**时间复杂度：** O(n × m̄)，其中 n 为人数，m̄ 为密码平均值  
**空间复杂度：** O(n)

---

## 测试用例

**输入：**
```
6          # 初始报数上限 m = 6
7          # 7 个人
3 1 7 2 4 8 4  # 密码依次为 3, 1, 7, 2, 4, 8, 4
```

**执行过程：**
```
第 1 轮：报 6 次 → 第 6 人出列（密码 8），m = 8
第 2 轮：报 8 次 → 第 7 人出列（密码 4），m = 4
第 3 轮：报 4 次 → 第 4 人出列（密码 2），m = 2
第 4 轮：报 2 次 → 第 1 人出列（密码 3），m = 3
第 5 轮：报 3 次 → 第 5 人出列（密码 4），m = 4
第 6 轮：报 4 次 → 第 2 人出列（密码 1），m = 1
第 7 轮：第 3 人出列（密码 7）
```

**输出：**
```
6 7 4 1 5 2 3
```

---

## 总结

**核心收获：**
1. 循环链表的构建和维护（尾指针指向头节点）
2. 通过删除后继节点避免查找前驱的技巧
3. 约瑟夫环的模拟算法实现

**关键难点：**
- 理解为什么循环 `m-1` 次而非 `m` 次
- 维护循环链表的正确性（尤其是删除最后一个节点时）
- Pair 结构存储编号和密码的设计

**扩展思考：**
- 双向循环链表是否能提升效率？
- 能否用数学公式直接求最后幸存者？